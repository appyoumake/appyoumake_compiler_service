{
  "name": "pm2-interface",
  "version": "1.1.0",
  "description": "Interact with pm2 via RPC and receive real time notifications",
  "author": {
    "name": "Strzelewicz Alexandre",
    "email": "as@unitech.io",
    "url": "http://unitech.io"
  },
  "engines": {
    "node": ">=0.8"
  },
  "main": "index.js",
  "dependencies": {
    "axon": "2.0.0",
    "pm2-axon-rpc": "~0.2.0",
    "debug": "*"
  },
  "keywords": [
    "cli",
    "fault tolerant",
    "sysadmin",
    "tools",
    "pm2",
    "node-pm2",
    "monitoring",
    "process manager",
    "forever",
    "process configuration",
    "clustering",
    "cluster cli",
    "cluster",
    "cron",
    "devops",
    "dev ops"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/Unitech/pm2-interface.git"
  },
  "license": "Apache v2",
  "readme": "# pm2-interface (for pm2 version >= 0.6.0)\n\npm2-interface permits you to interact with [PM2](https://github.com/Unitech/pm2) the process manager for NodeJS.\n\nYou can **control all exposed methods** by the pm2 deamon [God](https://github.com/Unitech/pm2/blob/master/lib/God.js) and also **receive real time notifications** for example for a process who got an unexpectedException, who's starting/stopping.\n\n## RPC methods\n\n- `ipm2.rpc.prepareJson(json_app, cwd, fn)` send a JSON configuration to start app(s) in the cwd folder\n- `ipm2.rpc.getMonitorData({}, fn)` receive all related informations about supervised process (cpu/ram/pid...)\n- `ipm2.rpc.getSystemData({}, fn)` receive all data about process managed by pm2 and computer resources usage\n- `ipm2.rpc.startProcessId(integer, fn)` start a process by id (pm_id) who his state is stopped\n- `ipm2.rpc.stopProcessId(integer, fn)` stop a process by id (pm_id)\n- `ipm2.rpc.stopAll({}, fn)` stop all process\n- `ipm2.rpc.reload(data, fn)` reload all apps (only for networked apps)\n- `ipm2.rpc.killMe(data, fn)` kill pm2 daemon\n- `ipm2.rpc.findByScript(string, fn)` send you back the informations about a specific process\n- `ipm2.rpc.restartProcessId(integer, fn)` restart a process by id (pm_id)\n- `ipm2.rpc.restartProcessName(string, fn)` restart all processes who have the given name\n- `ipm2.rpc.deleteProcess(string, fn)` stop and delete all processes from the pm2 database\n- `ipm2.rpc.deleteAll(data, fn)` stop and delete all processes\n- `ipm2.rpc.msgProcess(opts, fn)` send msg `opts.msg` to process at `opts.id` or all processes with `opts.name`\n\n## Notifications\n\n- `process:online` when a process is started/restarted\n- `process:exit` when a process is exited\n- `process:exception` When a process has received an uncaughtException\n\n**Advanced feature** : You can use `process.send({ type : 'my:message', data : {}})` in your Node apps. When you emit a message, they will be redirected to pm2 and sent back to the pm2-interface bus. This can be coupled with `rpc.msgProcess(opts, fn)` to allow 2-way communication between managed processes and pm2-interface - see second Example below.\n\n> It should be noted that `process.send` will be undefined if there is no parent process. Therefore a check of `if (process.send)` may be advisable.\n\n## Example\n\n```javascript\nvar ipm2 = require('pm2-interface')();\n\nipm2.on('ready', function() {\n  console.log('Connected to pm2');\n\n  ipm2.bus.on('*', function(event, data){\n    console.log(event, data.pm2_env.name);\n  });\n\n  setTimeout(function() {\n    ipm2.rpc.restartProcessId(0, function(err, dt) {\n      console.log(dt);\n    });\n  }, 2000);\n\n\n  ipm2.rpc.getMonitorData({}, function(err, dt) {\n    console.log(dt);\n  });\n});\n```\n\n## Example 2-way\n\nin your process script\n```javascript\nif (send in process) {\n  process.on(\"message\", function (msg) {\n    if ( \"type\" in msg && msg.type === \"god:heap\" ) {\n        var heap = process.memoryUsage().heapUsed\n      process.send({type:\"process:heap\", heap:heap})\n    }\n  })\n}\n\nvar myMemoryLeak = []\n\nsetInterval( function () {\n  var object = {}\n  for (var i = 0; i < 10000; i++) {\n    object[\"key\"+i] = Math.random().toString(36).substring(7)\n  }\n\n  myMemoryLeak.push(object)\n\n}, Math.round(Math.random()*2000))\n```\nin monitoring script\n```javascript\nvar ipm2 = require('pm2-interface')()\n\nipm2.on('ready', function() {\n\n    console.log('Connected to pm2')\n\n    ipm2.bus.on('process:heap', function(data){\n        console.log(\"process heap:\", data)\n    })\n\n\n    setInterval( function () {\n        var msg = {type:\"god:heap\"}   // god: is arbitrary and used to distinguish incoming & outgoing msgs\n        ipm2.rpc.msgProcess({name:\"worker\", msg:msg}, function (err, res) {\n            if (err) console.log(err)\n            else console.log(res)\n        })\n    }, 5000)\n})\n```\nStart pm2 and monitoring script + output:\n```shell\npm2 start worker.js -i 3 --name worker\nnode monitor.js\n\nsent 3 messages   # coming from the console.log(res)\nprocess heap: { pm_id: 0, msg: { type: 'process:heap', heap: 43416064 } }\nprocess heap: { pm_id: 1, msg: { type: 'process:heap', heap: 18373704 } }\nprocess heap: { pm_id: 2, msg: { type: 'process:heap', heap: 80734256 } }\nsent 3 messages\nprocess heap: { pm_id: 0, msg: { type: 'process:heap', heap: 61994096 } }\nprocess heap: { pm_id: 1, msg: { type: 'process:heap', heap: 22437400 } }\nprocess heap: { pm_id: 2, msg: { type: 'process:heap', heap: 116622432 } }\nsent 3 messages\nprocess heap: { pm_id: 0, msg: { type: 'process:heap', heap: 79641168 } }\nprocess heap: { pm_id: 1, msg: { type: 'process:heap', heap: 32260112 } }\nprocess heap: { pm_id: 2, msg: { type: 'process:heap', heap: 156047904 } }\n\npm2 delete all\n```\n\n## Disconnect\n\nSince pm2-interface interacts with PM2 via sockets, any script which uses pm2-interface will remain alive even when the node.js event loop is empty. `process.exit()` can be called to forcefully exit, or, if your script has finished making calls to PM2, you may call `ipm2.disconnect()` to disconnect the socket connections and allow node to exit automatically.\n\n```javascript\nipm2.on('ready', function() {\n\n  // ...\n\n  ipm2.disconnect();\n});\n```\n\n> Calling `disconnect()` means \"I am entirely done interacting with PM2.\" You will no longer be able to receive messages on `ipm2.bus` or send requests on `ipm2.rpc`. To reconnect you must completely start over with a new ipm2 object.\n\n## Ideas\n\n- Catching exceptions and fowarding them by mail\n- A web interface to control PM2\n\n## Apache v2 License\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/Unitech/pm2-interface/issues"
  },
  "_id": "pm2-interface@1.1.0",
  "_from": "pm2-interface@~1.1.0"
}
